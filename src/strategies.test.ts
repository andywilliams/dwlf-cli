import { Command } from 'commander';
import { createStrategiesCommand } from './strategies';

// Mock the config and api-client modules
jest.mock('./config', () => ({
  isAuthenticated: jest.fn(),
  getApiKey: jest.fn(),
  getApiUrl: jest.fn(),
}));

jest.mock('./api-client', () => ({
  DWLFApiClient: jest.fn().mockImplementation(() => ({
    get: jest.fn(),
    post: jest.fn(),
  })),
  normalizeSymbol: jest.fn((symbol: string) => symbol.toUpperCase()),
}));

describe('Strategies Command', () => {
  let strategiesCommand: Command;

  beforeEach(() => {
    strategiesCommand = createStrategiesCommand();
    jest.clearAllMocks();
  });

  describe('Command Structure', () => {
    test('should create a command named "strategies"', () => {
      expect(strategiesCommand.name()).toBe('strategies');
    });

    test('should have the correct alias', () => {
      expect(strategiesCommand.alias()).toBe('strat');
    });

    test('should have the correct description', () => {
      expect(strategiesCommand.description()).toBe('Manage trading strategies');
    });

    test('should have all required subcommands', () => {
      const subcommands = strategiesCommand.commands;
      const commandNames = subcommands.map(cmd => cmd.name());

      expect(commandNames).toContain('list');
      expect(commandNames).toContain('show');
      expect(commandNames).toContain('signals');
      expect(commandNames).toContain('activate');
      expect(commandNames).toContain('deactivate');
      expect(commandNames).toContain('status');
    });
  });

  describe('List Subcommand', () => {
    let listCommand: Command;

    beforeEach(() => {
      const subcommands = strategiesCommand.commands;
      listCommand = subcommands.find(cmd => cmd.name() === 'list')!;
    });

    test('should have the correct alias', () => {
      expect(listCommand.alias()).toBe('ls');
    });

    test('should have the correct description', () => {
      expect(listCommand.description()).toBe('List available strategies');
    });

    test('should have all required options', () => {
      const options = listCommand.options;
      const optionNames = options.map(opt => opt.long);

      expect(optionNames).toContain('--public-only');
      expect(optionNames).toContain('--mine-only');
      expect(optionNames).toContain('--limit');
    });

    test('should have correct default limit', () => {
      const limitOption = listCommand.options.find(opt => opt.long === '--limit');
      expect(limitOption?.defaultValue).toBe('20');
    });
  });

  describe('Show Subcommand', () => {
    let showCommand: Command;

    beforeEach(() => {
      const subcommands = strategiesCommand.commands;
      showCommand = subcommands.find(cmd => cmd.name() === 'show')!;
    });

    test('should have the correct alias', () => {
      expect(showCommand.alias()).toBe('info');
    });

    test('should have the correct description', () => {
      expect(showCommand.description()).toBe('Show detailed information about a strategy');
    });

    test('should require strategyId argument', () => {
      const args = showCommand.registeredArguments;
      expect(args).toHaveLength(1);
      expect(args[0]?.name()).toBe('strategyId');
      expect(args[0]?.required).toBe(true);
    });

    test('should have signals option with default', () => {
      const signalsOption = showCommand.options.find(opt => opt.long === '--signals');
      expect(signalsOption?.defaultValue).toBe('10');
    });
  });

  describe('Signals Subcommand', () => {
    let signalsCommand: Command;

    beforeEach(() => {
      const subcommands = strategiesCommand.commands;
      signalsCommand = subcommands.find(cmd => cmd.name() === 'signals')!;
    });

    test('should have the correct description', () => {
      expect(signalsCommand.description()).toBe('Show signals generated by a strategy');
    });

    test('should require strategyId argument', () => {
      const args = signalsCommand.registeredArguments;
      expect(args).toHaveLength(1);
      expect(args[0]?.name()).toBe('strategyId');
      expect(args[0]?.required).toBe(true);
    });

    test('should have all required options', () => {
      const options = signalsCommand.options;
      const optionNames = options.map(opt => opt.long);

      expect(optionNames).toContain('--symbol');
      expect(optionNames).toContain('--status');
      expect(optionNames).toContain('--limit');
    });

    test('should have correct default limit', () => {
      const limitOption = signalsCommand.options.find(opt => opt.long === '--limit');
      expect(limitOption?.defaultValue).toBe('20');
    });
  });

  describe('Activate Subcommand', () => {
    let activateCommand: Command;

    beforeEach(() => {
      const subcommands = strategiesCommand.commands;
      activateCommand = subcommands.find(cmd => cmd.name() === 'activate')!;
    });

    test('should have the correct description', () => {
      expect(activateCommand.description()).toBe('Activate a strategy for specific symbols');
    });

    test('should require strategyId and symbols arguments', () => {
      const args = activateCommand.registeredArguments;
      expect(args).toHaveLength(2);
      expect(args[0]?.name()).toBe('strategyId');
      expect(args[0]?.required).toBe(true);
      expect(args[1]?.name()).toBe('symbols');
      expect(args[1]?.variadic).toBe(true);
    });
  });

  describe('Deactivate Subcommand', () => {
    let deactivateCommand: Command;

    beforeEach(() => {
      const subcommands = strategiesCommand.commands;
      deactivateCommand = subcommands.find(cmd => cmd.name() === 'deactivate')!;
    });

    test('should have the correct description', () => {
      expect(deactivateCommand.description()).toBe('Deactivate a strategy for specific symbols');
    });

    test('should require strategyId and symbols arguments', () => {
      const args = deactivateCommand.registeredArguments;
      expect(args).toHaveLength(2);
      expect(args[0]?.name()).toBe('strategyId');
      expect(args[0]?.required).toBe(true);
      expect(args[1]?.name()).toBe('symbols');
      expect(args[1]?.variadic).toBe(true);
    });
  });

  describe('Status Subcommand', () => {
    let statusCommand: Command;

    beforeEach(() => {
      const subcommands = strategiesCommand.commands;
      statusCommand = subcommands.find(cmd => cmd.name() === 'status')!;
    });

    test('should have the correct description', () => {
      expect(statusCommand.description()).toBe('Show strategy activation status for symbols');
    });

    test('should require strategyId argument', () => {
      const args = statusCommand.registeredArguments;
      expect(args).toHaveLength(1);
      expect(args[0]?.name()).toBe('strategyId');
      expect(args[0]?.required).toBe(true);
    });

    test('should have symbol option', () => {
      const options = statusCommand.options;
      const optionNames = options.map(opt => opt.long);

      expect(optionNames).toContain('--symbol');
    });
  });

  describe('Integration Tests', () => {
    test('should be a valid Commander.js command', () => {
      expect(strategiesCommand).toBeInstanceOf(Command);
    });

    test('should be able to get help output', () => {
      expect(() => strategiesCommand.helpInformation()).not.toThrow();
    });

    test('should have valid subcommands with help', () => {
      const subcommands = strategiesCommand.commands;
      
      subcommands.forEach(subcommand => {
        expect(() => subcommand.helpInformation()).not.toThrow();
      });
    });
  });
});